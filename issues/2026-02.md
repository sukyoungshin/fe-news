# 2026-02 <img src="https://hits.sh/github.com/naver/fe-news/2026-02.svg?view=today-total" align=right>

# 📚 링크 & 읽을거리

## [웹퍼블리셔라는 말을 만든 이유](https://hyeonseok.com/blog/396)

<img src="https://hyeonseok.com/static/blog/web-publisher.jpg" width=500 />

2000년대 초반 한국에서 "웹 퍼블리셔"라는 용어가 어떻게 탄생했는지를 다룬 글이다. 당시 HTML 코딩을 담당하던 "코더"라는 직책은 그 역할의 중요성에 비해 전문성을 인정받지 못했고, 이를 개선하기 위해 웹 표준과 접근성에 초점을 맞춘 새로운 직무 명칭이 필요했다.

저자는 "퍼블리셔"라는 용어를 제안하며, 이 역할이 단순한 코딩을 넘어 웹 표준 준수, 접근성 구현, 디자인과 개발 사이의 가교 역할을 포함한다고 설명했다. 이 명칭은 이후 국내 웹 업계에서 널리 채택되어 현재까지 사용되고 있다.

한국 웹 개발 역사에서 직무 전문화가 어떻게 이루어졌는지를 보여주는 흥미로운 사례로, 글이 작성된 시점이 2007년임을 감안하고 읽어보기를 바란다.

## [Introducing: React Best Practices](https://vercel.com/blog/introducing-react-best-practices)

<img src="https://assets.vercel.com/image/upload/contentful/image/e5382hct74si/5VCSTefWazPIvZlDl3ZFbd/8996ca467f505fcec7d4f6fc19f9f1bd/image__15_.png" width=500 />

Vercel Labs에서 10년 이상의 React 및 Next.js 최적화 경험을 담은 [react-best-practices](https://github.com/vercel/react-best-practices) 저장소를 공개했다. 이 가이드는 8개 카테고리에 걸쳐 40개 이상의 규칙을 제공하며, 워터폴 제거, 번들 크기 감소, 서버 사이드 성능, 클라이언트 데이터 페칭, 리렌더링 최적화 등 중요도순으로 우선순위가 매겨져 있다.

각 규칙은 잘못된 패턴과 올바른 패턴을 코드 예시와 함께 설명한다. 예를 들어, 비동기 작업에서 불필요한 코드가 블로킹되는 것을 방지하는 방법을 다음과 같이 보여준다:

```javascript
// 잘못된 방식 (두 브랜치 모두 블로킹)
async function handleRequest(userId, skipProcessing) {
  const userData = await fetchUserData(userId);
  if (skipProcessing) return { skipped: true };
  return processUserData(userData);
}

// 올바른 방식 (필요할 때만 블로킹)
async function handleRequest(userId, skipProcessing) {
  if (skipProcessing) return { skipped: true };
  const userData = await fetchUserData(userId);
  return processUserData(userData);
}
```

이 가이드는 React 애플리케이션의 성능을 체계적으로 개선하고자 하는 개발자들에게 실용적인 참고 자료가 될 것이다.

## [Building Type-Safe Compound Components](https://tkdodo.eu/blog/building-type-safe-compound-components)

React와 TypeScript에서 타입 안전한 합성 컴포넌트(Compound Components)를 구축하는 방법을 다룬 글이다. 합성 컴포넌트 패턴이 적합한 경우(동적 자식 요소가 필요한 `RadioGroup` 등)와 props나 slots가 더 나은 경우(`Select`, `ModalDialog` 등)를 구분하여 설명한다.

핵심은 "Component Factory Pattern"으로, 합성 컴포넌트 간의 타입을 연결하여 각 자식 컴포넌트에 수동으로 타입을 명시하지 않아도 타입 안전성을 보장한다:

```typescript
// Component Factory Pattern 예시
export const createRadioGroup = <T extends GroupValue = never>() => ({
  RadioGroup: (props: RadioGroupProps<T>) => JSX.Element,
  RadioGroupItem: (props: Item<T>) => JSX.Element,
});

// 사용 예시
const Theme = createRadioGroup<ThemeValue>();

function ThemeSwitcher({ value, onChange }) {
  return (
    <Theme.RadioGroup value={value} onChange={onChange}>
      <Theme.RadioGroupItem value="system">🤖</Theme.RadioGroupItem>
      <Theme.RadioGroupItem value="light">☀️</Theme.RadioGroupItem>
      <Theme.RadioGroupItem value="dark">🌑</Theme.RadioGroupItem>
    </Theme.RadioGroup>
  );
}
```

합성 컴포넌트 패턴을 사용할 때 타입 추론 문제로 고민했던 개발자들에게 실용적인 해결책을 제시한다.

> [참고] 빠르게 읽고 싶다면 [번역글](https://rosetta.page/post/번역-타입-세이프한-합성-컴포넌트-만들기)을 참고하자.

## [tailwind llms.txt](https://github.com/tailwindlabs/tailwindcss.com/pull/2388#issuecomment-3717222957)

Tailwind CSS 문서에 LLM 최적화 엔드포인트(`/llms.txt`)를 추가하자는 PR이 거절된 사건과 그에 대한 Adam Wathan(Tailwind 창시자)의 설명이 담긴 논의다. 이 PR은 185개의 문서 파일을 LLM이 소비하기 쉬운 형태로 제공하려는 시도였다.

Adam Wathan은 PR 거절 이유로 Tailwind Labs의 심각한 비즈니스 상황을 언급했다. AI의 영향으로 인해 엔지니어링 팀의 75%가 해고되었고, 매출은 80% 가까이 감소했으며, 문서 트래픽은 2023년 초 대비 약 40% 하락했다고 밝혔다. 문서가 유료 제품을 알리는 유일한 채널이기 때문에, LLM 최적화 문서 제공이 트래픽 감소를 더 가속화할 수 있다는 우려를 표명했다.

이 논의는 AI 시대에 오픈소스 프로젝트의 지속 가능성, 문서 트래픽과 수익화의 관계, 그리고 LLM 친화적 콘텐츠 제공의 비즈니스적 영향에 대한 중요한 질문을 던진다. 많은 사람들이 Tailwind를 사용하면서도 재정적 지원을 하지 않는 현실에 대한 성찰도 포함되어 있다.

## [Using alternative browser engines in Japan](https://developer.apple.com/support/alternative-browser-engines-jp/)

iOS 26.2부터 일본 사용자를 위해 WebKit 이외의 브라우저 엔진을 사용할 수 있게 되었다. Apple은 "Web Browser Engine Entitlement"(전용 브라우저 앱용)와 "Embedded Browser Engine Entitlement"(앱 내 브라우징용) 두 가지 권한을 제공한다.

권한을 얻기 위해서는 엄격한 요구사항을 충족해야 한다. 기능적으로는 Web Platform Tests의 90%, Test262의 80%를 통과해야 하며, 보안 측면에서는 메모리 안전 언어 사용, Pointer Authentication Codes(PAC) 및 Memory Integrity Enforcement(MIE) 채택, 30일 이내 취약점 패치, 공개적인 취약점 공개 정책 등이 요구된다. 개인정보 보호 측면에서는 서드파티 쿠키 기본 차단, 사이트별 저장소 파티셔닝 등을 준수해야 한다.

EU의 Digital Markets Act(DMA)에 이어 일본에서도 대체 브라우저 엔진이 허용됨으로써, iOS 플랫폼의 브라우저 다양성이 확대되는 추세다.

## [React Slot/asChild Composition Pattern](https://boda.sh/blog/react-slot-aschild-pattern/)

기존 Radix UI가 대중화한 `asChild` prop과 `Slot` 패턴을 설명하고, Base UI의 방향성인 `render` prop과 `useRender` 훅을 소개한다.

합성 컴포넌트 패턴에 관심 있는 개발자라면, 재미있게 읽을 수 있을 것이다.

> [참고] 빠르게 읽고 싶다면 [번역글](https://rosetta.page/post/번역-react-slot-aschild-합성-패턴-xUJH8)을 참고하자.

## [Mitigating Denial-of-Service Vulnerability from Unrecoverable Stack Space Exhaustion for React, Next.js, and APM Users](https://nodejs.org/en/blog/vulnerability/january-2026-dos-mitigation-async-hooks)

`async_hooks`가 활성화된 상태에서 스택 오버플로우가 발생하면, Node.js가 복구 가능한 에러를 던지는 대신 즉시 종료 코드 7로 종료되는 취약점에 대한 설명이다. React Server Components, Next.js, 대부분의 APM 도구(Datadog, New Relic 등)가 `AsyncLocalStorage`를 사용하기 때문에 이 문제의 영향 범위가 매우 넓다.

문제의 핵심은 V8의 promise hook이 Promise 생성 시 동기적으로 호출되어 사용자 코드와 동일한 콜 스택에서 실행된다는 것이다. 깊은 재귀 호출로 스택이 고갈되면 `async_hooks` 콜백 내에서 에러가 발생하고, `TryCatchScope::kFatal`이 이를 치명적 에러로 처리하여 즉시 프로세스를 종료한다.

수정된 버전(Node.js 20.20.0, 22.22.0, 24.13.0, 25.3.0)에서는 스택 오버플로우 에러를 감지하여 치명적 에러로 처리하지 않고 사용자 코드로 다시 던지도록 변경되었다. 그러나 스택 오버플로우 동작은 ECMAScript 명세에 정의되지 않은 동작이므로, 공격자가 제어할 수 있는 재귀 깊이에 대해서는 입력 검증이나 깊이 제한을 통한 방어가 필요하다.

## [The Adolescence of Technology](https://www.darioamodei.com/essay/the-adolescence-of-technology)

Anthropic CEO Dario Amodei가 작성한 에세이로, AI 기술의 위험성과 이를 극복하는 방법에 대해 다룬다. 영화 Contact의 한 장면을 인용하며 "기술적 청소년기(technological adolescence)"를 어떻게 자멸하지 않고 살아남을 수 있는지에 대한 질문으로 시작한다.

에세이는 AI 위험을 5가지로 분류한다: 자율성 위험(AI가 적대적 의도를 가질 경우), 파괴를 위한 오용(테러리스트 등의 악용), 권력 장악을 위한 오용(독재자나 악의적 기업의 활용), 경제적 혼란(대규모 실업이나 부의 집중), 간접적 영향(급격한 기술 변화로 인한 불안정). 저자는 2026년 현재 AI 진보의 속도를 체감하고 있으며, AI가 이미 Anthropic 코드의 상당 부분을 작성하고 있어 피드백 루프가 가속화되고 있다고 언급한다.

[도머리즘(doomerism)](https://en.wikipedia.org/wiki/Doomer)을 피하면서도 위험을 현실적으로 인식하고 대비해야 한다고 강조하며, AI의 긍정적 측면을 다룬 이전 에세이 "Machines of Loving Grace"와 균형을 이루는 관점을 제시한다. 기술 발전의 불확실성을 인정하면서도 증거 기반의 신중한 접근이 필요함을 역설한다.

## [A few random notes from claude coding](https://x.com/karpathy/status/2015883857489522876)

전 OpenAI, Tesla AI 리더였던 Andrej Karpathy가 최근 몇 주간 Claude Code를 사용한 경험을 공유한 X 스레드다. 2025년 11월에는 80% 수동 코딩, 20% 에이전트 사용이었으나, 12월에는 80% 에이전트 코딩, 20% 수정/터치업으로 급격히 변화했다고 밝힌다.

주요 인사이트로는 IDE와 에이전트 스웜에 대한 과대광고 경계, LLM의 "끈질김(Tenacity)" - 사람이라면 포기했을 작업을 30분 동안 계속 시도해 결국 성공하는 모습에서 "AGI를 느낀다"고 표현한다. 또한 명령형이 아닌 선언적 접근(성공 기준을 주고 지켜보기)이 에이전트 활용의 핵심이라고 조언한다. 흥미롭게도 에이전트 사용으로 프로그래밍이 더 재미있어졌다고 하며, 단조로운 작업이 제거되고 창의적인 부분만 남기 때문이라고 설명한다.

2026년을 "Slopacolypse(저질 콘텐츠의 대홍수)"의 해로 예측하며, GitHub, Substack, arXiv, X/Instagram 등 모든 디지털 미디어에 걸쳐 AI 생성 저품질 콘텐츠가 넘칠 것이라고 경고한다. 10배 엔지니어의 생산성 격차가 더 커질 가능성, 제너럴리스트가 스페셜리스트를 앞설 가능성 등 여러 질문을 던진다.

## [The era of humans writing code is over](https://x.com/rough__sea/status/2013280952370573666)

Deno와 Node.js의 창시자 Ryan Dahl이 X에 올린 짧지만 강렬한 선언이다. "인간이 코드를 작성하는 시대는 끝났다"고 단언하며, 소프트웨어 엔지니어로서 정체성을 가진 이들에게는 불편할 수 있지만 사실이라고 말한다.

720만 뷰, 2만 좋아요, 4천 리포스트를 기록하며 큰 반향을 일으킨 이 게시물은, 소프트웨어 엔지니어에게 여전히 할 일이 있지만 직접 구문(syntax)을 작성하는 것은 더 이상 그 일이 아니라고 덧붙인다. Karpathy의 분석과 맥을 같이하며, 2026년 초 AI 코딩 도구의 급격한 발전이 업계에 가져온 인식 변화를 보여주는 상징적인 발언이다.

## [Boris Cherny의 Claude Code 사용법](https://x.com/bcherny/status/2007179832300581177)

<img src="https://pbs.twimg.com/media/G9rjZcwasAQpPN6?format=png&name=900x900" width=500>

Claude Code의 창시자 Boris Cherny가 직접 공유한 13가지 Claude Code 사용 팁이다. 많은 사람들이 그의 설정을 궁금해했는데, 놀랍게도 그의 설정은 상당히 "바닐라(기본)"하다고 밝힌다. Claude Code는 기본 상태에서도 훌륭하게 작동하도록 설계되어 있으며, 팀원 각자가 매우 다른 방식으로 사용한다고 한다.

주요 팁으로는 터미널에서 5개의 Claude를 병렬로 실행하고 탭에 1-5 번호를 붙여 시스템 알림으로 관리하는 방법, claude.ai/code에서 5-10개의 Claude를 추가로 병렬 실행하는 방법, 모든 작업에 Opus 4.5 with thinking 사용(더 크고 느리지만 조정이 덜 필요해 결과적으로 더 빠름), 팀 전체가 단일 CLAUDE.md를 git에 체크인하여 공유하고 Claude가 실수할 때마다 추가하는 방법 등이 있다.

워크플로우 측면에서는 대부분의 세션을 Plan 모드(shift+tab 두 번)로 시작하여 계획이 만족스러우면 auto-accept 모드로 전환, 매일 반복하는 "inner loop" 작업에 슬래시 명령어 활용, code-simplifier나 verify-app 같은 서브에이전트 활용, PostToolUse 훅으로 코드 포맷팅 자동화, `--dangerously-skip-permissions` 대신 `/permissions`로 안전한 명령어 사전 허용 등을 권장한다. 가장 중요한 팁으로는 "Claude에게 작업을 검증할 방법을 제공하라"를 꼽으며, 이 피드백 루프가 최종 결과물의 품질을 2-3배 향상시킨다고 강조한다.

> 참고
>
> - [Boris Cherny (Creator of Claude Code) On What Grew His Career And Building at Anthropic](https://www.youtube.com/watch?v=AmdLVWMdjOk) - Boris Cherny와의 인터뷰 영상

## [Agent Skills](https://agentskills.io/home)

AI 에이전트에게 새로운 능력과 전문 지식을 부여하기 위한 간단하고 오픈된 포맷이다. Anthropic에서 처음 개발하여 오픈 표준으로 공개했으며, 현재 Claude Code, Cursor, GitHub Copilot, VS Code, Gemini CLI 등 다양한 에이전트 제품에서 지원하고 있다.

Agent Skills는 에이전트가 발견하고 사용할 수 있는 지침, 스크립트, 리소스의 폴더다. 스킬 작성자는 한 번 만들어 여러 에이전트 제품에 배포할 수 있고, 팀과 기업은 조직의 지식을 버전 관리되는 재사용 가능한 패키지로 캡처할 수 있다. 도메인 전문 지식(법률 검토 프로세스, 데이터 분석 파이프라인 등)을 재사용 가능한 지침으로 패키징하거나, 반복 가능한 워크플로우를 일관되고 감사 가능한 프로세스로 만들 수 있다.

> 참고
>
> - [skills.sh](https://skills.sh/) - Skills의 오픈 에코시스템으로, `npx skills add <owner/repo>` 한 줄 명령어로 스킬 설치 가능
> - [vercel-labs/agent-skills](https://github.com/vercel-labs/agent-skills) - Vercel의 AI 코딩 에이전트용 스킬 컬렉션 (react-best-practices, web-design-guidelines 등)

## [Putting the "You" in CPU](https://cpu.land/)

<img src="https://cpu.land/banner.png" width=500>

컴퓨터에서 프로그램을 실행할 때 정확히 무슨 일이 일어나는지 궁금했던 적이 있다면 이 글이 도움이 될 것이다. Hack Club에서 제작한 이 교육 자료는 멀티프로세싱의 작동 원리, 시스템 콜의 실체, 하드웨어 인터럽트를 통한 메모리 관리, Linux의 실행 파일 로딩 방식을 상세히 설명한다.

7개 챕터로 구성되어 있으며, 기초(Basics), 멀티태스킹(Multitasking), 프로그램 실행(Exec), [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) 포맷, [페이징(Paging)](https://en.wikipedia.org/wiki/Memory_paging), [Fork-Exec](https://en.wikipedia.org/wiki/Fork%E2%80%93exec) 패턴을 다룬다. 저자는 시스템 프로그래밍에 대한 종합적인 자료가 대학 외부에는 많지 않아, 다양한 출처의 정보를 40페이지 분량의 노트로 정리한 후 이 글을 작성했다고 한다.

웹 버전 외에도 단일 페이지 버전과 PDF 버전을 제공하여, 원하는 형태로 학습할 수 있다. 시스템 프로그래밍의 기초를 이해하고 싶은 프런트엔드 개발자에게도 유용한 자료다.

## [Node.js 16 to 25 Benchmarks: How Performance Evolved Over Time](https://www.repoflow.io/blog/node-js-16-to-25-benchmarks-how-performance-evolved-over-time)

Node.js 16부터 25까지의 버전별 성능 변화를 벤치마크한 분석 글이다. RepoFlow 팀이 Express 워크로드를 기반으로 LTS와 non-LTS 릴리스 전체를 테스트하여 런타임 성능의 실제 향상 폭을 측정했다.

벤치마크는 HTTP GET 처리량, JSON.parse/stringify 속도, SHA-256 해싱, 64KB 버퍼 복사, Array map/reduce, 문자열 연결, 정수 루프 연산 등 다양한 항목을 포함한다. 특히 Node.js 25에서는 숫자 연산과 루프 집약적인 작업에서 눈에 띄는 성능 향상이 확인되었다. 테스트는 Apple M4 환경에서 각 항목을 5회씩 실행하여 중앙값(p50)을 기준으로 측정했다.

모든 애플리케이션에서 극적인 성능 향상을 기대하기는 어렵지만, 타이트한 루프나 연산 집약적인 로직, 데이터 변환 파이프라인이 많은 워크로드에서는 최신 Node.js 버전으로의 업그레이드가 실질적인 이점을 제공할 수 있다.

# 🕹 튜토리얼

## [Introducing the \<geolocation\> HTML element](https://developer.chrome.com/blog/geolocation-html-element)

<img src="https://developer.chrome.com/static/blog/geolocation-html-element/image/hero.png" width=500 />

Chrome 144에서 도입된 새로운 `<geolocation>` HTML 요소를 소개하는 글이다. 기존의 JavaScript API(`navigator.geolocation.getCurrentPosition()`)를 사용한 위치 요청 방식에서, 선언적이고 사용자 행동 기반의 경험으로 전환함으로써 보일러플레이트 코드를 줄이고, 사용자 의도를 더 명확히 전달해 브라우저의 자동 차단(quiet blocks)을 방지할 수 있다.

주요 속성으로는 `autolocate`(자동 위치 요청), `accuracymode`(`precise` 또는 `approximate`), `watch`(지속적 위치 추적) 등이 있으며, 사용자 신뢰를 보장하기 위한 스타일링 제약도 포함되어 있다:

```html
<geolocation
  onlocation="handleLocation(event)"
  autolocate
  accuracymode="precise"
>
</geolocation>

<script>
  function handleLocation(event) {
    if (event.target.position) {
      const { latitude, longitude } = event.target.position.coords;
      console.log('Location retrieved:', latitude, longitude);
    } else if (event.target.error) {
      console.error('Error:', event.target.error.message);
    }
  }
</script>
```

점진적 향상(Progressive Enhancement) 전략과 커스텀 폴백 패턴, 폴리필도 지원하여 기존 브라우저와의 호환성을 유지할 수 있다.

## [Stop turning everything into arrays and do less work instead](https://allthingssmitty.com/2026/01/12/stop-turning-everything-into-arrays-and-do-less-work-instead/)

JavaScript의 Iterator Helpers를 활용해 불필요한 배열 생성과 작업을 줄이는 방법을 다룬 글이다. 흔히 사용하는 `data.filter().map().slice()` 체이닝은 각 단계마다 새 배열을 생성하고, 10개만 필요해도 수천 개를 모두 처리한다는 문제가 있다.

Iterator Helpers는 배열이 아닌 이터레이터 객체에서 동작하는 체이닝 메서드로, `map`, `filter`, `take`, `drop`, `flatMap`, `find`, `some`, `every`, `reduce`, `toArray` 등을 제공한다. 핵심은 **lazy evaluation**으로, 값이 실제로 필요할 때만 처리하고 조건이 충족되면 즉시 멈춘다:

```javascript
const visibleItems = items
  .values() // 이터레이터 생성
  .filter(isVisible)
  .map(transform)
  .take(10) // 10개만 취하고 중단
  .toArray();
```

가상화 리스트, 무한 스크롤, 페이지네이션 API 등 일부만 처리하면 되는 UI 패턴에 특히 유용하다. 다만 랜덤 접근(`items[5]`)이 필요하거나, 이터레이터가 한 번 소비되면 재사용이 불가능하다는 점, 디버깅 시 `console.log`가 이터레이터를 소비한다는 점은 주의해야 한다. 모든 모던 브라우저와 Node 22+에서 지원된다.

## [The senior engineer's guide to AI coding](https://www.youtube.com/watch?v=LvLdNkgO-N0)

<img src="https://i.ytimg.com/vi/LvLdNkgO-N0/maxresdefault.jpg" width=500>

시니어 엔지니어를 위한 AI 코딩 가이드 영상으로, 컨텍스트 로딩, 커스텀 훅, 자동화에 대해 다룬다. 고급 Claude Code 기술인 Mermaid 다이어그램 활용, stop 훅 등의 실용적인 내용을 담고 있다.

AI 코딩 도구를 단순히 사용하는 것을 넘어, 시니어 엔지니어의 관점에서 어떻게 효과적으로 활용할 수 있는지 보여준다. 특히 컨텍스트 관리와 자동화 설정을 통해 생산성을 극대화하는 방법을 구체적으로 설명한다.

## [How Claude Code Works](https://www.youtube.com/watch?v=RFKCzGlAU6Q)

<img src="https://i.ytimg.com/vi/RFKCzGlAU6Q/maxresdefault.jpg" width=500>

PromptLayer의 Jared Zoneraich가 진행하는 이 영상에서는 Claude Code의 내부 작동 방식을 분석한다. AI 코딩 어시스턴트가 어떻게 코드를 이해하고 생성하는지, 그 메커니즘을 깊이 있게 살펴본다.

Claude Code를 더 효과적으로 활용하고 싶은 개발자나, AI 코딩 도구의 작동 원리에 관심 있는 이들에게 유용한 기술적 인사이트를 제공한다.

## [Everything you need to know about act() in React tests](https://howtotestfrontend.com/resources/react-act-function-everything-you-need-to-know)

React 테스트에서 자주 마주치는 `act()` 함수에 대한 완전 가이드다. "update was not wrapped in act(...)" 에러의 의미와 해결 방법, React와 Testing Library 중 어디서 act를 import해야 하는지, 언제 act를 사용해야 하고 언제 사용하지 말아야 하는지를 상세히 설명한다.

훅 테스트 시 act() 사용법, 비동기 동작 테스트, act()의 동기/비동기 동작 차이 등 실무에서 자주 부딪히는 상황별 가이드를 제공한다. 특히 React Testing Library 메서드를 act()로 감싸지 말아야 하는 이유도 설명하여, 테스트 코드의 품질을 높이는 데 도움이 된다.

# 📦 코드와 도구

## [jQuery 4.0.0](https://blog.jquery.com/2026/01/17/jquery-4-0-0)

2006년 1월 존 레식이 jQuery를 발표한 지 벌써 20년이 지났으나 jQuery는 여전히 전 세계의 수많은 웹사이트에서 사용되고 있다. 그리고 버전 3 이후 약 10년 만의 메이저 업데이트인 jQuery 4.0.0이 출시되었다. 이번 버전에서는 IE 10 이하 지원이 제거되고, Trusted Types와 CSP(Content Security Policy) 지원이 추가되었으며, 소스 코드가 ES 모듈로 마이그레이션되었다.

여러 deprecated API들이 제거되었다: `jQuery.isArray`(대신 `Array.isArray` 사용), `jQuery.parseJSON`(대신 `JSON.parse` 사용) 등. focus 이벤트 순서도 변경되어 blur 이벤트가 focus 이벤트 전에 발생하도록 조정되었다. slim 빌드에서는 Deferreds와 Callbacks가 제거되어 네이티브 Promise 사용을 권장한다.

jQuery가 여전히 많은 프로젝트에서 사용되고 있는 만큼, 업그레이드 시 deprecated API 사용 여부와 이벤트 순서 변경으로 인한 영향을 사전에 점검하는 것이 중요하다.

> [참고] jQuery 4.0.0 beta 버전은 2024년 2월에 공개되었다.
> [당시 FE-NEWS 소개글](./2024-03.md#jquery-400-beta)

## [RollDown 1.0](https://voidzero.dev/posts/announcing-rolldown-rc)

<img src="https://voidzero.dev/covers/announcing-rolldown-rc.jpg" width=500 />

Rust로 작성된 JavaScript/TypeScript 번들러 Rolldown의 1.0 RC가 발표되었다. Rollup보다 10-30배 빠른 성능을 제공하면서도 Rollup 플러그인 API와의 호환성을 유지한다. Vite 8에서 기본 번들러로 채택될 예정이며, esbuild와 Rollup을 대체하여 개발/프로덕션 환경 간의 일관된 동작을 제공할 계획이다.

주요 기능으로는 Rollup 호환 플러그인 API, TypeScript/JSX 변환 내장(Oxc 기반), 네이티브 CJS/ESM 상호운용(`@rollup/plugin-commonjs` 불필요), 내장 Node.js 모듈 해석, webpack 스타일의 세밀한 코드 스플리팅(`output.codeSplitting`) 등이 있다.

```javascript
import { defineConfig } from 'rolldown';

export default defineConfig({
  input: 'src/main.js',
  output: { file: 'dist/bundle.js' },
});
```

beta.1 이후 3,400개 이상의 커밋이 반영되었으며, Rollup 테스트 900개 이상, esbuild 테스트 670개 이상을 통과한다. RC 기간 동안 API 안정성이 보장되며, 2026년 Q3에 1.0 안정 버전 출시가 예정되어 있다.

## [Yarn 6 Preview](https://yarn6.netlify.app/blog/2026-01-28-yarn-6-preview)

<img src="https://yarn6.netlify.app/_astro/social-media-background.e0Uy3hrD.png" width=300 />

Yarn의 Rust 포팅 계획이 공개되었다. 1년 이상 진행된 이 프로젝트는 6-8개월 내에 완료될 예정이며, 대폭 향상된 반응성과 낮은 메모리 사용량을 제공할 것이다. 벤치마크에서 Next.js 프로젝트의 warm cache 설치가 기존 577ms에서 184ms로, Gatsby 프로젝트는 1.7s에서 0.3s로 단축되었다.

새로운 기능으로 Yarn Switch와 Lazy Installs가 도입된다. Yarn Switch는 Corepack의 대체제로, `packageManager` 필드를 읽어 적절한 Yarn 버전을 자동으로 다운로드하고 실행한다. Lazy Installs는 `yarn run` 등의 명령 실행 시 아티팩트가 동기화되지 않았으면 자동으로 설치를 수행하는 기능으로, Zero Installs의 장점은 유지하면서 저장소 용량 문제를 해결한다.

버전 로드맵에 따르면 현재 JS 코드베이스는 Yarn 5.x 시리즈로 계속 개발되고, Rust 기반의 Yarn 6.x 안정 버전은 2026년 Q3 이후 출시될 예정이다. Datadog에서 이미 실험적으로 프로덕션에 배포되어 테스트 중이다.

## [Shadcn Create](https://ui.shadcn.com/create)

shadcn/ui는 최근 많은 개발자들의 선택을 받았으나, 모든 애플리케이션이 똑같아 보이는 문제가 발생하기 시작했다. Shadcn Create는 이러한 문제를 해결하기 위한 시각적 프로젝트 빌더다. 코드를 작성하기 전에 컴포넌트 라이브러리, 스타일, 색상, 아이콘, 폰트, 반경 등 모든 것을 커스터마이즈할 수 있으며, 변경 사항을 실시간으로 미리 볼 수 있다. 설정은 URL 파라미터로 저장되어 링크 하나로 전체 디자인 시스템을 공유할 수 있다.

5가지 새로운 스타일이 도입되었다: **Vega**(클래식), **Nova**(컴팩트한 패딩과 마진), **Maia**(부드럽고 둥근 느낌), **Lyra**(각지고 날카로움, mono 폰트와 어울림), **Mira**(고밀도 인터페이스용). 이는 단순한 테마가 아니라 시스템 전반의 컴포넌트 동작과 느낌에 영향을 준다. 또한 Radix UI의 유지보수 둔화에 대응해 **Base UI**를 대안 기반 라이브러리로 선택할 수 있게 되었다. 아이콘도 Lucide 외에 Tabler Icons, HugeIcons를 지원하며, 셔플 기능(R키)으로 다양한 디자인 조합을 빠르게 탐색할 수 있다.

프로덕션 레벨의 빌딩 블록도 제공된다. Elevenlabs(오디오 UI), GitHub(레포지토리/프로필), Vercel(애널리틱스 대시보드), ChatGPT(AI 채팅 인터페이스) 등 실제 제품에 바로 적용 가능한 완성된 컴포넌트 예제들이다. Next.js, Vite, TanStack Start를 지원하며, v0와의 통합으로 AI 기반 UI 생성도 가능하다.

## [Claude Usage Tracker](https://github.com/hamed-elfayome/Claude-Usage-Tracker)

<img src="https://github.com/hamed-elfayome/Claude-Usage-Tracker/raw/main/.github/cover.jpg" width=500>

Claude AI 사용량 제한을 실시간으로 모니터링하는 네이티브 macOS 메뉴 바 애플리케이션이다. Swift와 SwiftUI로 개발되어 가볍고 빠르며, 5시간 세션 윈도우, 주간 사용량 제한, Opus 전용 소비량을 추적할 수 있다.

주요 기능으로는 멀티 프로필 지원(무제한 Claude 계정 관리), Claude Code CLI 연동 및 자동 자격 증명 전환, 커스터마이징 가능한 인터페이스(5가지 아이콘 스타일, 모노크롬 모드), 터미널 상태 표시줄 통합 등이 있다. 로컬 저장, 원격 전송 없음, 클라우드 동기화 없음의 프라이버시 우선 설계가 특징이다.

## [Claude Code 완전 가이드 70가지 팁](https://drive.google.com/file/d/1fV_OTeqPB4m9J7gK22wM1_YqeV3zKvDi/view)

Claude Code 활용을 위한 70가지 팁을 담은 한국어 PDF 가이드다. 기본 사용법부터 고급 기능까지 체계적으로 정리되어 있어, Claude Code를 처음 접하는 개발자부터 이미 사용 중인 개발자까지 유용하게 참고할 수 있다.

## [45 Claude Code Tips: From Basics to Advanced](https://github.com/ykdojo/claude-code-tips)

YK(ykdojo)가 정리한 Claude Code 45가지 팁 모음이다. 커스텀 상태 표시줄 스크립트, 시스템 프롬프트 절반으로 줄이기, Gemini CLI를 Claude Code의 미니언으로 활용하기, 컨테이너에서 Claude Code 실행하기 등 실용적인 팁들을 담고 있다.

주요 팁으로는 필수 슬래시 명령어 학습, 음성으로 Claude Code와 대화하기, Git/GitHub CLI 프로처럼 사용하기, 터미널 별칭 설정, 컨텍스트 적극적 압축, Git worktree로 병렬 브랜치 작업, 마크다운 활용, 인터랙티브 PR 리뷰 등이 있다. dx 플러그인도 포함되어 있어 개발자 경험을 향상시킬 수 있다.

## [Everything Claude Code](https://github.com/affaan-m/everything-claude-code)

Anthropic 해커톤 우승자가 10개월 이상 매일 실제 제품을 만들며 발전시킨 Claude Code 설정 컬렉션이다. 프로덕션 수준의 에이전트, 스킬, 훅, 명령어, 규칙, MCP 설정이 포함되어 있다.

Shorthand Guide(설정, 기초, 철학)와 Longform Guide(토큰 최적화, 메모리 지속성, 평가, 병렬화)를 제공하며, 토큰 최적화(모델 선택, 시스템 프롬프트 슬리밍, 백그라운드 프로세스), 메모리 지속성(세션 간 컨텍스트 자동 저장/로드 훅), 지속적 학습(세션에서 패턴 자동 추출하여 재사용 가능한 스킬로 변환), 검증 루프, 병렬화(Git worktree, cascade 방식) 등의 고급 주제를 다룬다.

## [Ripple TS](https://github.com/Ripple-TS/ripple)

<img src="https://raw.githubusercontent.com/Ripple-TS/ripple/main/assets/ripple-desktop.png" width=500>

React, Solid, Svelte의 장점을 결합한 TypeScript UI 프레임워크다. Inferno, React, Lexical, Svelte 5에 기여한 [@trueadm](https://github.com/trueadm)이 만들었다. `.ripple` 확장자를 사용하는 TS-first 설계로, TypeScript 통합과 LLM 개발자 경험을 모두 향상시키는 고유한 문법을 제공한다.

주요 특징으로는 `track`과 `@` 문법을 활용한 [세밀한 반응성(fine-grained reactivity)](https://docs.solidjs.com/concepts/intro-to-reactivity), 업계 최고 수준의 렌더링 속도/번들 크기/메모리 사용량, 반응형 컬렉션(`#[]` 배열, `#{}` 객체), 컴포넌트 수준 CSS 자동 스코핑, VSCode 확장/Prettier/ESLint 지원 등이 있다. 현재 SPA 전용이며 SSR 지원은 준비 중이다.

```typescript
// Counter.ripple
component Counter {
  track count = 0;

  <button @click={() => count++}>
    Count: {count}
  </button>
}
```

## [React2AWS](https://github.com/mmarinovic/React2AWS)

<img src=https://github.com/mmarinovic/React2AWS/raw/main/public/banner.svg width=500>

React 컴포넌트를 작성하듯 JSX 문법으로 AWS 인프라를 정의하고, 이를 프로덕션 수준의 Terraform 코드로 변환해 주는 웹 기반 도구다. 라이브 에디터에서 구문 강조와 자동 완성을 지원하며, 코드 작성과 동시에 AWS 리소스를 실시간으로 시각화할 수 있다.

Tailwind CSS에서 영감을 받은 className 기반 설정 패턴을 사용한다. VPC, RDS, Fargate, EC2, Lambda, S3, DynamoDB, ALB, SecurityGroup 등 9가지 핵심 AWS 서비스를 지원하며, 컴포넌트를 중첩하면 자동으로 네트워크 토폴로지가 구성된다. 서버리스 API, 마이크로서비스, 이커머스 플랫폼 등 8가지 스타터 템플릿도 제공한다.

```jsx
<VPC className="cidr-10.0.0.0/16" name="main">
  <RDS
    className="engine-postgres instance-lg storage-100gb multi-az"
    name="api-db"
  />
  <Fargate className="cpu-256 memory-512" name="api-service" />
</VPC>
```

## [HMPL.js](https://hmpl-lang.dev/)

서버 지향 커스터마이징 가능한 JavaScript용 템플릿 언어다. HTML을 fetch하고 안전하게 렌더링하며, 앱을 동적이고 현대적이면서도 가볍게 유지할 수 있다. HTMX와 유사한 접근 방식이지만, 더 JavaScript 친화적인 API를 제공한다.

HTMX가 HTML 속성 기반으로 작동하는 반면, HMPL은 JavaScript 코드 내에서 템플릿을 정의하고 컴파일하는 방식을 사용한다. 서버에서 HTML을 가져와 클라이언트에서 렌더링하는 하이브리드 접근 방식으로, 번들 크기를 줄이면서도 동적인 인터랙션을 구현할 수 있다.

```javascript
import { compile } from 'hmpl-js';

const templateFn = compile(`
  {{ src: "/api/users", after: "load" }}
`);

const result = templateFn();
document.getElementById('app').appendChild(result.response);
```

## [typex](https://github.com/AbhishekMandilkar/typex)

터미널에서 `npx typex-cli`로 바로 실행할 수 있는 미니멀한 타자 속도 테스트 도구이다. 실시간 WPM과 정확도를 측정하며 30/60/90초 테스트를 지원한다.

## [OpenClaw](https://github.com/openclaw/openclaw)

<img src="https://raw.githubusercontent.com/openclaw/openclaw/main/docs/assets/openclaw-logo-text-dark.png" width=500>

상표권 이슈로 Clawdbot에서 Moltbot으로, 다시 최종적으로 OpenClaw로 리브랜딩된 오픈소스 프로젝트다. Anthropic의 명칭 변경 요구와 리브랜딩 과정에서의 계정 탈취 및 스캠 소동을 겪으며 최근 가장 화제가 되었다.

Claude 등 LLM을 기반으로 브라우저를 제어하고 시스템 명령을 직접 수행하는 '액션 중심' 에이전트를 표방한다. Node.js와 Playwright 기반으로 동작하며, WhatsApp이나 Discord 같은 익숙한 메신저 UI를 통해 로컬 환경을 원격 제어할 수 있는 접근성이 강점이다. 초기 지적된 보안 우려를 해소하기 위해 샌드박스 실행 환경과 사용자 승인 절차를 도입하며 아키텍처를 보완하고 있다.

단순한 챗봇을 넘어 '행동하는 AI'의 실무적 아키텍처를 보여주는 대표적인 사례다. FE 개발자에게는 브라우저 자동화 기술이 LLM과 결합하여 기존의 사용자 인터페이스를 어떻게 대체하거나 확장할 수 있는지 보여주는 유용한 레퍼런스다.
