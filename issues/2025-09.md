# 2025-09 <img src="https://hits.sh/github.com/naver/fe-news/2025-09.svg?view=today-total" align=right>

# 📚 링크 & 읽을거리

## [Augmented Coding: Beyond the Vibes](https://tidyfirst.substack.com/p/augmented-coding-beyond-the-vibes)

소프트웨어 공학의 거장인 Kent Beck이 [BPlusTree3](https://github.com/KentBeck/BPlusTree3) 라이브러리 구축을 통해 "Augmented Coding"과 "Vibe Coding"의 차이점을 설명한다.

Vibe Coding은 코드 품질보다 동작에만 관심을 갖는 반면, Augmented Coding은 코드 복잡성, 테스트, 커버리지를 중시하며 TDD와 [Tidy First 원칙](https://search.shopping.naver.com/book/catalog/47016221620)을 AI와 함께 적용한다. 프로젝트 과정에서 Rust와 Python 버전을 모두 개발했고, 심지어 C 확장까지 작성하여 성능 경쟁력을 확보했다. AI가 개발 과정을 보조하지만 여전히 프로그래밍의 본질은 유지되며, 오히려 더 의미 있는 프로그래밍 결정에 집중할 수 있게 된다는 관점을 제시한다.

> [참고]
> - Augmented Coding을 위해 사용한 [시스템 프롬프트](https://tidyfirst.substack.com/p/augmented-coding-beyond-the-vibes)를 참고하라.
> - [Kiro와 함께 Augmented Coding 기반 소프트웨어 개발하기](https://aws.amazon.com/ko/blogs/tech/augmented-coding-with-kiro/)  

## [Code w/ Claude Developer Conference](https://www.youtube.com/playlist?app=desktop&list=PLf2m23nhTg1P5BsOHUOXyQz5RhfUSSVUi)

<img src="https://i.ytimg.com/vi/EvtPBaaykdo/maxresdefault.jpg" width=500>

Anthropic의 첫 번째 개발자 컨퍼런스로 2025년 5월 22일 샌프란시스코에서 개최된 실습 중심의 컨퍼런스 영상 모음이다.

Claude 4 모델 발표와 함께 Anthropic API, CLI 도구, MCP 프로토콜을 활용한 실제 구현 사례와 모범 사례를 다룬다. 총 20개의 세션으로 구성되어 있으며 AI 에이전트 구축, 프롬프팅 기법, Claude를 활용한 자동화, 다양한 플랫폼 연동 등을 포함한다. 특히 [Amazon Bedrock](https://aws.amazon.com/ko/bedrock/), [Google Cloud Vertex AI](https://cloud.google.com/vertex-ai) 등 클라우드 플랫폼 통합 방법과 실제 기업들의 Claude 활용 사례도 소개한다.

## [Safeguarding VS Code against prompt injections](https://github.blog/security/vulnerability-research/safeguarding-vs-code-against-prompt-injections/)

<img src="https://github.blog/wp-content/uploads/2025/08/img2-copilot-tool-calling-flow.png?w=1536" width=500>

VS Code Copilot Chat의 에이전트 모드에서 발생할 수 있는 프롬프트 인젝션 공격과 보안 대응 방안을 다룬다.

외부 데이터가 채팅 세션에 포함될 때 악의적인 지시사항이 포함된 GitHub 이슈나 PR을 통해 LLM이 속아서 GitHub 토큰 유출, 민감한 파일 접근, 임의 코드 실행 등을 수행할 수 있다. 주요 취약점으로는 [fetch_webpage 도구](https://github.com/microsoft/vscode/blob/0958948eb9be33d16c94783e6185cc50c15959e7/src/vs/workbench/contrib/chat/electron-browser/tools/fetchPageTool.ts#L40)의 URL 파싱 오류, Simple Browser 도구를 통한 데이터 유출, editFile 도구의 자동 저장 기능 악용 등이 있다. VS Code는 사용자 확인 절차 강화, 워크스페이스 외부 파일 접근 제한, MCP 서버 신뢰 검증, 샌드박싱 환경 활용 등의 보안 개선 사항을 도입했다.

## [Vibe coding and the future of programming](https://www.youtube.com/watch?v=f15bhW7juwI)

<img src="https://i.ytimg.com/vi/f15bhW7juwI/maxresdefault.jpg" width=500>

Windows의 작업 관리자를 개발했던 MS 출신 프로그래머이자 기업가인 [Dave Plummer](https://en.wikipedia.org/wiki/Dave_Plummer)가 Lex Fridman과 함께 'Vibe Coding'과 프로그래밍의 미래에 대해 논의한다.

Vibe Coding은 코드의 세부 사항보다는 결과물에만 관심을 갖는 프로그래밍 접근법으로, AI 도구를 활용하여 빠르게 작동하는 코드를 생성하는 데 중점을 둔다. Plummer는 순수한 즐거움과 열정으로 코딩을 배운 자신의 세대와 달리, 현재는 AI가 코드 작성을 보조하는 시대가 되었다고 말한다. 하지만 시니어 개발자에게는 AI가 생산성을 높이는 강력한 도구가 될 수 있으며, 개발자가 시스템의 작동 원리를 이해하고 있을 때 가장 효과적이라고 강조한다.

## [The State of CSS 2025](https://2025.stateofcss.com/)

CSS 생태계의 현황을 파악하는 연례 CSS 생태계 설문조사 결과가 공개되었다.

CSS는 Web apps(82%) 개발이 주요 용도로 자리잡으며 문서 레이아웃에서 인터랙티브 앱 중심으로 진화했다. Anchor Positioning이 가장 큰 브라우저 호환성 이슈로 부상했으며(거의 2배 증가), View Transition API와 Container style queries가 급상승했다. 반면 CSS Nesting과 `:has()`는 메이저 브라우저 지원으로 문제에서 제외되었다. 개발자들이 가장 원하는 기능은 Mixins와 Masonry Layout이며, Grid, `:has()`, CSS Nesting이 최근 5년간 CSS 작성 방식을 가장 크게 바꾼 게임 체인저로 평가받는다. CSS에 대한 개발자 만족도는 지속적으로 상승하고 있어 언어의 빠른 개선 속도가 긍정적으로 평가되고 있다.

## [Agent Client Protocol (ACP)](https://github.com/zed-industries/agent-client-protocol)

<img src="https://zed.dev/img/acp/banner-dark.webp" width=500>

코드 에디터와 AI 코딩 에이전트 간의 표준화된 통신 프로토콜이다.

기존에는 각 에디터가 모든 에이전트에 대해 개별 통합 작업을 해야 했지만, ACP는 Language Server Protocol(LSP)과 유사하게 표준 프로토콜을 제공하여 상호 운용성을 보장한다. JSON-RPC over stdio를 사용하며 MCP의 JSON 표현을 재사용하되, diff 표시 등 에이전틱 코딩 UX 요소를 위한 커스텀 타입을 포함한다. 현재 Zed와 neovim(CodeCompanion 플러그인 통해), Gemini CLI 등이 지원되며, 에디터와 에이전트가 독립적으로 혁신할 수 있도록 디커플링을 실현한다.

## [DeepWiki](https://deepwiki.com/)

GitHub의 모든 저장소에 대해 대화형 AI 문서를 제공하는 서비스다.

"GitHub용 딥 리서치"라고 할 수 있으며, 사용자가 특정 저장소의 코드와 문서에 대해 질문하고 대화할 수 있는 최신 문서를 제공한다. Microsoft VS Code, React, Node.js, TensorFlow 등 수많은 인기 오픈소스 프로젝트들이 이미 지원되고 있으며, 개발자들이 복잡한 코드베이스를 더 쉽게 이해할 수 있도록 돕는다. 저장소 링크를 검색하거나 붙여넣기만 하면 해당 프로젝트에 대한 AI 문서를 바로 이용할 수 있다.

## [AGENTS.md](https://agents.md/)

AI 코딩 에이전트를 위한 간단하고 개방적인 형식으로, 2만 개 이상의 오픈소스 프로젝트에서 사용되고 있다.

README.md가 인간 기여자를 위한 것이라면, AGENTS.md는 "에이전트를 위한 README"로서 AI가 프로젝트에서 효과적으로 작업할 수 있도록 컨텍스트와 지침을 제공하는 전용 파일이다. 설정 명령어, 코드 스타일, 테스트 지침, 보안 고려사항 등 AI가 필요로 하는 상세한 정보들을 포함한다. OpenAI Codex, Cursor, Aider, Gemini CLI 등 다양한 AI 코딩 도구들과 호환되며, 프로젝트 루트에 AGENTS.md 파일을 생성하여 각 서브프로젝트별로 맞춤형 지침을 제공할 수 있다.

## [Cognitive Load is what matters](https://github.com/zakirullin/cognitive-load/blob/main/README.ko.md)

<img src="https://github.com/zakirullin/cognitive-load/raw/main/img/cognitiveloadv6.png" width=500>

개발자가 작업을 완료하기 위해 생각해야 하는 양인 '인지 부하'를 중심으로 소프트웨어 개발의 복잡성을 다룬다.

인간의 작업 기억은 평균 4개의 덩어리만 담을 수 있으며, 이 임계값을 초과하면 코드 이해가 극도로 어려워진다. 복잡한 조건문, 깊은 상속 구조, 과도한 작은 모듈들, DRY 원칙 남용, 프레임워크와의 긴밀한 결합 등이 외재적 인지 부하를 증가시키는 요인들이다. 대신 의미 있는 변수명, 조기 반환, 깊은 모듈(간단한 인터페이스 + 복잡한 기능), 자체 설명적 코드를 통해 인지 부하를 줄일 수 있다. 새로운 개발자가 프로젝트에 빠르게 기여할 수 있도록 하는 것이 핵심이다.

## [Vibe Shift? Senior Developers Ship nearly 2.5x more AI Code than Junior Counterparts](https://www.fastly.com/blog/senior-developers-ship-more-ai-code)

<img src="https://www.fastly.com/cimages/ocb1q9kflo7k/4ZAKgzUySDabMbNiTCcCXV/677ebd54cc6e4fb2fac918e7ce4cca90/HowMuchCodeisAI.png?auto=avif&crop=1924:1398,smart&width=1800" width=500>

클라우드 컴퓨팅 서비스를 제공하는 Fastly가 25년 7월, 791명 개발자 대상으로 한 설문조사 결과에 대한 내용으로, 시니어 개발자들이 주니어 개발자보다 AI 생성 코드를 2.5배 더 많이 프로덕션에 배포한다는 흥미로운 현상을 보고한다.

10년 이상 경력 개발자의 약 1/3이 배포 코드의 절반 이상이 AI 생성이라고 답한 반면, 0-2년 경력 개발자는 13%만이 그렇다고 응답했다. 시니어 개발자들은 AI 코드를 수정하는 데 더 많은 시간을 투자하지만(30% vs 17%), 전반적으로 더 빠른 개발 속도를 경험한다고 보고한다. 흥미롭게도 거의 모든 개발자가 AI 도구의 환경 비용을 인지하고 있으며, 개발자의 80%가 AI 도구로 인해 코딩이 더 즐거워졌다고 답했다. 하지만 최근 연구에서는 AI 사용 시 작업 완료 시간이 오히려 19% 증가한다는 상반된 결과도 나왔다.

## [You’re Loading Fonts Wrong](https://www.jonoalderson.com/performance/youre-loading-fonts-wrong/)

웹폰트는 [LCP](https://web.dev/articles/lcp), [CLS](https://web.dev/articles/cls) 등 핵심 성능 지표와 접근성에 직접적인 영향을 주지만, 많은 사이트가 과도한 포맷/[Glyph](https://developer.mozilla.org/en-US/docs/Glossary/Glyph), 늦은 요청, 서드파티 스니펫 등 잘못된 전략으로 성능을 저하시킨다. 글은 시스템 폰트를 우선 적용하고, WOFF2 단일 포맷 사용, 지능적 서브셋팅, 프리로드 및 인라인 선언을 통한 `@font-face` 최적화, 변수 폰트의 선택적 활용, 폴백 폰트의 메트릭 정렬을 권장한다. 또한 라이선스 제약(서브셋 금지, 조회수 기반 과금 등)을 반드시 점검해야 함을 강조한다.  

마지막으로, 브라우저 개발자 도구, [WebPageTest](https://www.webpagetest.org/), [Glyphhanger](https://github.com/zachleat/glyphhanger), [fonttools](https://github.com/fonttools/fonttools) 같은 도구로 폰트 크기와 로딩 시점을 측정하고 예산을 설정해 빠른 초기 렌더링과 일관된 타이포그래피를 달성하는 방법을 제시한다. 결과적으로 폰트 로딩은 단순 디자인 요소가 아니라, 사용자 경험과 성능 품질을 좌우하는 핵심 요소임을 일깨운다.

# 🕹 튜토리얼

## [JavaScript Microtasks: A Comprehensive Guide and the Event Loop](https://codedynasty.dev/posts/JavaScript-Microtasks-A-deep-look-and-comparision-to-defer)

JavaScript 이벤트 루프와 마이크로태스크에 대한 포괄적인 가이드다.

이벤트 루프는 콜 스택, 매크로태스크 큐, 마이크로태스크 큐 3가지 구성 요소로 동작하며, 마이크로태스크는 Promise 콜백과 [queueMicrotask()](https://developer.mozilla.org/en-US/docs/Web/API/Window/queueMicrotask) 함수를 통해 활용된다.

마이크로태스크는 현재 동기 코드 완료 후 브라우저 렌더링 전에 실행되어 상태 업데이트 배치 처리와 UI 일관성 유지에 중요한 역할을 한다. Go의 defer와 달리 FIFO 순서로 처리되며 비동기적으로 작동한다. 실제 폼 제출, 테마 관리자 등의 예제를 통해 마이크로태스크가 어떻게 효율적인 렌더링과 결정적 실행 순서를 제공하는지 설명한다.

## [An Illustrated Guide to OAuth](https://www.ducktyped.org/p/an-illustrated-guide-to-oauth)

<img src="https://substackcdn.com/image/fetch/$s_!BvOT!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F253a935b-e09d-42d2-b5f2-47c6a5b1a35e_1024x598.png" width=500>

OAuth의 동작 원리를 시각적으로 설명하는 상세한 가이드다.

[YNAB](https://www.ynab.com/) 서비스에서 Chase 은행에 연결하는 예제를 통해 OAuth 플로우를 설명한다. OAuth는 사용자가 제3자 앱에 비밀번호를 직접 제공하지 않고도 데이터 접근을 허용하는 방식으로, 액세스 토큰을 통해 작동한다. 사용자 동의 플로우와 인증 코드 플로우 두 부분으로 구성되며, 보안을 위해 URL에 액세스 토큰을 직접 포함하지 않고 인증 코드를 통해 백엔드에서 안전하게 교환한다. 클라이언트 ID, 클라이언트 시크릿, 리다이렉트 URI, 스코프 등의 개념과 프론트채널/백채널 구분, PKCE 등 고급 보안 메커니즘도 다룬다.

## [Big O](https://samwho.dev/big-o/)

Big O 표기법을 시각적이고 인터랙티브한 방식으로 설명하는 튜토리얼이다.

함수의 입력 크기가 증가할 때 실행 시간이 어떻게 변화하는지를 설명하며, O(1) 상수, O(log n) 로그, O(n) 선형, O(n²) 제곱 시간 복잡도를 다룬다. sum 함수 최적화, 버블 정렬의 O(n²) 성능, 이진 탐색의 O(log n) 효율성 등을 실제 코드와 함께 보여준다. 실무에서 활용할 수 있는 팁으로 Set을 통한 O(1) 검색, 인덱스 기반 반복으로 O(n²)에서 O(n)으로 개선, 메모이제이션을 통한 캐싱 최적화 등을 제시한다. 각 개념마다 실행 가능한 예제와 그래프를 제공하여 시간 복잡도의 차이를 직관적으로 이해할 수 있도록 한다.

## [What are OKLCH colors?](https://jakub.kr/components/oklch-colors)

<img src="https://jakub.kr/_next/image?url=https%3A%2F%2Foiszjiwtfc65cwa2.public.blob.vercel-storage.com%2Fcolor-wheel.png&w=2048&q=75" width=300>

OKLCH 색상 모델은 인간의 시각적 인지에 기반한 색상 모델로, `Lightness(명도), Chroma(채도), Hue(색상)` 세 가지 값으로 구성된다.

RGB나 HSL과 달리 perceptual uniformity(지각적 균일성)를 제공하여 같은 명도값으로 다른 색상을 만들면 실제로 동일한 밝기로 보인다. 색상 팔레트 생성이 용이하고, 명도 변경 시 색상 드리프트가 없으며, Display-P3 같은 확장 색 공간을 지원한다. CSS Color Module Level 4에서 표준화되어 모든 모던 브라우저에서 지원되며, [@supports 지시어](https://developer.mozilla.org/en-US/docs/Web/CSS/@supports)를 통한 폴백 제공도 가능하다.

> 저자가 개발한 [oklch.fyi](https://oklch.fyi) 도구도 함께 확인하라.

# 📦 코드와 도구

## [ForesightJS](https://github.com/spaansba/ForesightJS)

<img src="https://github.com/user-attachments/assets/f5650c63-4489-4878-bd72-d8954c6a739b" width=500>

사용자 의도를 예측하여 콘텐츠를 미리 로드하는 경량 라이브러리다.

마우스 궤적, 키보드 탐색, 스크롤 패턴을 분석해 사용자가 클릭하기 전에 콘텐츠를 미리 가져온다. 기존 hover 기반 프리페칭의 100-200ms 지연 시간을 개선하고, 뷰포트 기반 프리페칭의 불필요한 리소스 낭비 문제(Next.js 홈페이지에서 1.59MB)를 해결한다. 키보드 사용자도 지원하여 접근성을 향상시키며, 터치 디바이스에서는 onTouchStart와 Viewport Enter 전략을 사용한다. 3G 이하 연결이나 데이터 절약 모드에서는 자동으로 비활성화되어 사용자 환경을 고려한다. 설정 없이 바로 작동하며 TypeScript를 지원한다.

> [공식 문서](https://foresightjs.com/docs/getting-started/what-is-foresightjs)

## [Gitingest](https://github.com/coderamp-labs/gitingest)

<img src="https://raw.githubusercontent.com/coderamp-labs/gitingest/refs/heads/main/docs/frontpage.png" width=500>

GitHub 저장소를 LLM에서 사용할 수 있는 프롬프트 친화적 텍스트 데이터로 만들어 준다.

프로젝트의 기본 폴더 구조와 LLM이 사용할 수 있도록 프로젝트의 개요와 정보 등을 빠르게 얻을 수 있도록 한다.
브라우저에서 직접 접근하거나 브라우저 확장 프로그램을 통해 사용할 수 있다.

```
# 사용예
브라우저의 주소창에서 저장소의 도메인을 "github.com" → "gitingest.com"으로 변경하면 된다.

https://github.com/naver/billboard.js
→ https://gitingest.com/naver/billboard.js
```

## [Claude Code Templates](https://www.aitmpl.com/)

```sh
 ██████╗██╗      █████╗ ██╗   ██╗██████╗ ███████╗    ██████╗ ██████╗ ██████╗ ███████╗    ████████╗███████╗███╗   ███╗██████╗ ██╗      █████╗ ████████╗███████╗███████╗
██╔════╝██║     ██╔══██╗██║   ██║██╔══██╗██╔════╝   ██╔════╝██╔═══██╗██╔══██╗██╔════╝    ╚══██╔══╝██╔════╝████╗ ████║██╔══██╗██║     ██╔══██╗╚══██╔══╝██╔════╝██╔════╝
██║     ██║     ███████║██║   ██║██║  ██║█████╗     ██║     ██║   ██║██║  ██║█████╗         ██║   █████╗  ██╔████╔██║██████╔╝██║     ███████║   ██║   █████╗  ███████╗
██║     ██║     ██╔══██║██║   ██║██║  ██║██╔══╝     ██║     ██║   ██║██║  ██║██╔══╝         ██║   ██╔══╝  ██║╚██╔╝██║██╔═══╝ ██║     ██╔══██║   ██║   ██╔══╝  ╚════██║
╚██████╗███████╗██║  ██║╚██████╔╝██████╔╝███████╗   ╚██████╗╚██████╔╝██████╔╝███████╗       ██║   ███████╗██║ ╚═╝ ██║██║     ███████╗██║  ██║   ██║   ███████╗███████║
 ╚═════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝    ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝       ╚═╝   ╚══════╝╚═╝     ╚═╝╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚══════╝
```

Anthropic Claude Code를 위한 준비된 템플릿과 설정 모음이다.

에이전트, 명령어, 설정, 훅, MCP, 템플릿 등을 카테고리별로 제공하며, 검색과 원클릭 복사 기능을 지원한다. 스택 빌더를 통해 개인화된 개발 환경을 구성할 수 있고, 클립보드에 복사하거나 장바구니에 담아 한번에 설치할 수 있다. 추가 도구로는 AI 개발 세션 실시간 모니터링을 위한 Analytics, 설치 상태 진단을 위한 Health Check, Claude Opus 4.1 응답 분석을 위한 Conversation Monitor 등을 npx 명령어로 제공한다.

## [ReactBits](https://reactbits.dev/)

창의적인 개발자를 위한 애니메이션 React 컴포넌트 라이브러리다.

텍스트 애니메이션, 백그라운드 효과, 상호작용 컴포넌트 등 다양한 창의적인 컴포넌트를 포함한다. CSS와 Tailwind 스타일링 옵션을 원클릭으로 전환할 수 있고, 랜딩 페이지를 돋보이게 만드는 고도로 커스터마이징 가능한 애니메이션 컴포넌트를 제공한다. [Pixel Blast](https://reactbits.dev/backgrounds/pixel-blast), [Splash Cursor](https://reactbits.dev/cursor/splash-cursor) 등의 독특한 효과들이 있으며, 전 세계 개발자들로부터 "가장 예술적인 UI 컴포넌트 라이브러리"라는 평가를 받고 있다. [Vue Bits](https://vue-bits.dev/) 버전도 별도로 제공된다.

## [Live LLM Token Counter](https://github.com/BedirT/LLM-Token-Counter-VSCode)

<img src="https://github.com/BedirT/LLM-Token-Counter-VSCode/raw/main/images/icon.png" width=300>

VS Code 확장으로 제공되는 LLM 토큰 카운터 도구다.

실시간으로 텍스트의 토큰 수를 계산하여 LLM API 사용 시 비용 예측과 토큰 제한 관리에 도움을 준다. 다양한 토크나이저를 지원하며, 선택한 텍스트나 전체 문서의 토큰 수를 즉시 확인할 수 있다. AI 모델 작업 시 프롬프트 최적화와 효율적인 토큰 사용량 관리를 위한 필수 도구로 활용할 수 있다.

## [Griddy.io](http://Griddy.io)

CSS Grid를 시각적이고 인터랙티브하게 학습할 수 있는 도구다.

실시간으로 grid-template-columns, grid-template-rows, grid gaps, justify-items, align-items 등의 속성을 조작하며 결과를 즉시 확인할 수 있다. 그리드 요소를 추가/제거하고, 각 열과 행의 크기를 fr, px, %, auto 단위로 설정할 수 있으며, 컨테이너와 아이템의 정렬 방식을 직관적으로 실험해볼 수 있다. 실시간으로 생성되는 CSS 코드를 확인할 수 있어 CSS Grid 속성의 작동 원리를 체험적으로 이해하는 데 도움이 된다.
